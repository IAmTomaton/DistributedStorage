# DistributedStorage

!Внимание!
Сокеты не постоянная вещь и в самом начале работы, при пресылке сообщений и выключении
они какое-то время "дуплят", поэтому желательно выдерживать временные интервалы
между связанными действиями. Например на локальной машине можно выдержать 0.2 сек между вызывами
.send_get(key) и .get(key), иначе будет исключение, т.к. пакет ещё не успел дойти и т.п.

Тоже важная инфа!
Anytask не дружит с сокетами, поэтому файл с тестами test_integration.py не работает и валит всю проверку.
Поэтому у файла test_integration. необходимо в конце добавить расширение py и запустить вручную.
Как доказательство покрытия в >90% могу прислать скрин Данила :) у меня pytest-cov не работает :(

Как пользоваться:

В пакете distributed_storage есть 3 класса и 4 исключения:

Исключения:

DSException - базовое исключение.
Возникает в единственной ситуации, когда при попытке взять ключ из клиента client.get(key),
почему-то проверка на ошибки прошла, но ключа нет в локальном хранилище(хз когда такое может произойти,
по идее ни как не сможет).
От него наследуются все остальные исключения, чтобы их было легко ловить.

NoKeyException - отсутствие значения по ключу на серверах.
Появляется при отправке запроса с ключём, значение по которому ещё не было добавлено.
Возникает при попытке вызвать .get(key) по этому ключу(если конечно пакет с ответом успел прийти).

NoServerException - отсутствие всех серверов, которые могут хранить данный ключ.
Возникает если все вычисленные сервера откючены. К примеру для ключа был вычислен хэш 2,
а сервера с номерами 2 и 3 не работают.

NoRouterException - отсутствие подключения к серверу.
Возникает при попытке отправить какой либо запрос, когда клиент ещё не успел подключиться к роутеру.

Исключение KeyError возникает при попытке получить значение по ключу отсутствующем в локальном хранилище.
Например если пакет со значением ещё не успел дойти.

Классы:

Server

Для создания класса сервера ему нужно указать ip и порт роутера для подключения,
а также его номер(как номер ячейки в словаре).
Также можно указать путь до директории в которой будут храниться файлы со значениями
(в противном случае они будут создаваться рядом)
Server(ip, port, number[, path=""])

Для запуска необходимо вызвать метод .start()
Для остановки необходимо вызвать метод .turn_off()

Router

Для создания класса сервера ему нужно указать ip и порт на которые будут подключаться сервера,
ip и порт на которые будут подключаться клиенты, а так же количество подключамых серверов.
Router(server_ip, server_port, client_ip, client_port, number_servers)


Для запуска необходимо вызвать метод .start()
Для остановки необходимо вызвать метод .turn_off()

Client

Для создания класса сервера ему нужно указать ip и порт роутера для подключения.
Также можно указать номер базы данных, так ключи из одной базы данных не будут видны из другой,
по умолчанию стоит нулевая.
Client(ip, port[, database_number=0])

Для запуска необходимо вызвать метод .start()
Для остановки необходимо вызвать метод .turn_off()

Для того чтобы положить значение необходимо вызвать метод .send_set(key, value)

Для того чтобы получть значение сначала необходимо вызвать метод .send_get(key) для отправки запроса.
Затем когда пакет придёт и сохранится в локальном хранилище, нужно вызвать метод .get(key)
и получить значение(или исключекнием в лицо) при этом значение удалится из локального хранилища
и для повторного полученя необходимо снова отправить запрос.

Чтобы проверить наличие ключа в локальном хранилище можно воспользоваться методом .contains(key)

Аналогично чтобы получить список всех доступмых на данный момент ключей необходимо отправить запрос
с помощью методоа .send_get_keys().
А для того чтобы получитьсписок ключей необходимо вызвать метод .keys(), при этом
если пакет ещё не пришёл вернётся пустой массив. Если пакет уже пришёл, после вызова метода
список ключей в клиенте очистится.

ФИЧИ!

Ранняя коррекция и буфер:
Когда на роутер приходит set пакет чтобы положить значение, то сначала вычисляется хэш ключа
и этот пакет рассылается на сервера с номерами от хэша до хэша + число дублирования(1).
Если сервер в данный момент был отключен, то на роутере в специальной таблице оставляется заявка
для этого сервера на данный ключ. Если же все нужные сервера были отключены,
то пакет по данному ключу записывается в буфер роутера(словарь).
Когда сервер подключается, по происходит обновление таблицы заявок, мы пытаемся дописать в сервера
данные которые прошли через роутер пока этот сервер был отключен.
Мы просматриваем какие ключи какому серверу нужны и пытаемся их получить.
Сначала мы идём в буфер, если там есть такой ключ, мы его берём, удаляем, а пакет отправляем на сервер.
Если нет, то пытаемся подгрузить с других серверов, если они включены, иначе оставляем заявку в покое.

Поздняя коррекция:
Если произошла внештатная ситуация, к примеру сервер начисто вырубило в тот момент
когда он записывал какое-то значение и оно не сохранилось, при этом ни кто кроме сервера об этом не знает
и думают что значение на нём есть.
Т.к. запрос на ключ отправляется всем серверам с нужными номером, то в роутере анализируются
входящие от серверов пакеты и если по какому-то запросу с одного сервера пришло значение,
а с другого ошибка его отсутствия, то роутер отправляет на 2-й сервер пакет с 1-го,
чтобы скоректировать его пямять.
